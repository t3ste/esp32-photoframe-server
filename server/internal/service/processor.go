package service

import (
	"fmt"
	"image"
	"image/jpeg"
	"os"
	"os/exec"
	"path/filepath"

	_ "golang.org/x/image/bmp" // Register BMP decoder
)

type ProcessorService struct {
	cliPath string
}

func NewProcessorService(cliPath string) *ProcessorService {
	return &ProcessorService{
		cliPath: cliPath,
	}
}

func (s *ProcessorService) ProcessImage(img image.Image, options map[string]string) ([]byte, []byte, error) {
	// 1. Create temp directory for this operation
	tmpDir, err := os.MkdirTemp("", "process-*")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// 2. Save input image
	inputPath := filepath.Join(tmpDir, "source.jpg")
	f, err := os.Create(inputPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input file: %w", err)
	}

	// Encode as JPEG
	if err := jpeg.Encode(f, img, &jpeg.Options{Quality: 95}); err != nil {
		f.Close()
		return nil, nil, fmt.Errorf("failed to encode input image: %w", err)
	}
	f.Close()

	// 3. Prepare CLI arguments
	// node cli.js <input> -o <outputDir>
	args := []string{s.cliPath, inputPath, "-o", tmpDir}

	// Add options if needed (mapping map to CLI args)
	for k, v := range options {
		args = append(args, "--"+k, v)
	}

	cmd := exec.Command("node", args...)

	// Capture output for debugging
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("CLI execution failed: %s\nOutput: %s\n", err, string(output))
		return nil, nil, fmt.Errorf("cli execution failed: %s", err)
	}

	// Log CLI output for debug
	// fmt.Printf("CLI Output: %s\n", string(output))

	// 4. Read outputs
	// CLI generates source.png and source.jpg (thumbnail)
	pngPath := filepath.Join(tmpDir, "source.png")
	thumbPath := filepath.Join(tmpDir, "source.jpg")

	processedBytes, err := os.ReadFile(pngPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read processed image: %s. CLI Output: %s", err, string(output))
	}

	thumbBytes, err := os.ReadFile(thumbPath)
	if err != nil {
		// If thumbnail missing, maybe acceptable? But CLI should generate it.
		// We'll return nil for thumbBytes if missing, handling it gracefully
		fmt.Printf("Warning: Thumbnail not generated by CLI. Path: %s\n", thumbPath)
		thumbBytes = nil
	} else {
		// fmt.Printf("Processor: Successfully generated thumb (%d bytes)\n", len(thumbBytes))
	}

	return processedBytes, thumbBytes, nil
}
