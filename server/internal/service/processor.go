package service

import (
	"fmt"
	"image"
	"image/jpeg"
	"os"
	"os/exec"
	"path/filepath"

	_ "golang.org/x/image/bmp" // Register BMP decoder
)

type ProcessorService struct {
}

func NewProcessorService() *ProcessorService {
	return &ProcessorService{}
}

func (s *ProcessorService) ProcessImage(img image.Image, options map[string]string) ([]byte, []byte, error) {
	// 1. Create temp directory for this operation
	tmpDir, err := os.MkdirTemp("", "process-*")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// 2. Save input image
	inputPath := filepath.Join(tmpDir, "source.jpg")
	f, err := os.Create(inputPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input file: %w", err)
	}

	// Encode as JPEG
	if err := jpeg.Encode(f, img, &jpeg.Options{Quality: 95}); err != nil {
		f.Close()
		return nil, nil, fmt.Errorf("failed to encode input image: %w", err)
	}
	f.Close()

	// 3. Prepare output paths
	outputPath := filepath.Join(tmpDir, "output.png")
	thumbPath := filepath.Join(tmpDir, "thumbnail.jpg")

	// 4. Prepare CLI arguments for epaper-image-convert
	// epaper-image-convert input.jpg output.png -d WxH -t thumbnail.jpg [options]
	args := []string{inputPath, outputPath}

	// Add dimension if specified
	if dimension, ok := options["dimension"]; ok {
		args = append(args, "-d", dimension)
	}

	// Add thumbnail output
	args = append(args, "-t", thumbPath)

	// Add other options (excluding dimension which we already handled)
	for k, v := range options {
		if k != "dimension" {
			args = append(args, "--"+k, v)
		}
	}

	cmd := exec.Command("epaper-image-convert", args...)

	// Capture output for debugging
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("CLI execution failed: %s\nOutput: %s\n", err, string(output))
		return nil, nil, fmt.Errorf("cli execution failed: %s", err)
	}

	// Log CLI output for debug
	// fmt.Printf("CLI Output: %s\n", string(output))

	// 5. Read outputs
	processedBytes, err := os.ReadFile(outputPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read processed image: %s. CLI Output: %s", err, string(output))
	}

	thumbBytes, err := os.ReadFile(thumbPath)
	if err != nil {
		// If thumbnail missing, maybe acceptable? But CLI should generate it.
		// We'll return nil for thumbBytes if missing, handling it gracefully
		fmt.Printf("Warning: Thumbnail not generated by CLI. Path: %s\n", thumbPath)
		thumbBytes = nil
	} else {
		// fmt.Printf("Processor: Successfully generated thumb (%d bytes)\n", len(thumbBytes))
	}

	return processedBytes, thumbBytes, nil
}
